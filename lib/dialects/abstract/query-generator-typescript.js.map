{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/query-generator-typescript.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport isObject from 'lodash/isObject';\nimport type { ModelStatic } from '../../model.js';\nimport type { Sequelize } from '../../sequelize.js';\nimport { isPlainObject, isString } from '../../utils/check.js';\nimport { quoteIdentifier } from '../../utils/dialect.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport type { TableName, TableNameWithSchema } from './query-interface.js';\nimport type { AbstractDialect } from './index.js';\n\nexport type TableNameOrModel = TableName | ModelStatic;\n\n// keep REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS updated when modifying this\nexport interface RemoveIndexQueryOptions {\n  concurrently?: boolean;\n  ifExists?: boolean;\n  cascade?: boolean;\n}\n\nexport const REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof RemoveIndexQueryOptions>(['concurrently', 'ifExists', 'cascade']);\n\nexport interface QueryGeneratorOptions {\n  sequelize: Sequelize;\n  dialect: AbstractDialect;\n}\n\n// DO NOT MAKE THIS CLASS PUBLIC!\n/**\n * This is a temporary class used to progressively migrate the AbstractQueryGenerator class to TypeScript by slowly moving its functions here.\n * Always use {@link AbstractQueryGenerator} instead.\n */\nexport class AbstractQueryGeneratorTypeScript {\n\n  protected readonly dialect: AbstractDialect;\n  protected readonly sequelize: Sequelize;\n\n  constructor(options: QueryGeneratorOptions) {\n    if (!options.sequelize) {\n      throw new Error('QueryGenerator initialized without options.sequelize');\n    }\n\n    if (!options.dialect) {\n      throw new Error('QueryGenerator initialized without options.dialect');\n    }\n\n    this.sequelize = options.sequelize;\n    this.dialect = options.dialect;\n  }\n\n  protected get options() {\n    return this.sequelize.options;\n  }\n\n  describeTableQuery(tableName: TableNameOrModel) {\n    return `DESCRIBE ${this.quoteTable(tableName)};`;\n  }\n\n  showIndexesQuery(_tableName: TableNameOrModel): string {\n    throw new Error(`showIndexesQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  removeIndexQuery(\n    _tableName: TableNameOrModel,\n    _indexNameOrAttributes: string | string [],\n    _options?: RemoveIndexQueryOptions,\n  ): string {\n    throw new Error(`removeIndexQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  // TODO: rename to \"normalizeTable\" & move to sequelize class\n  extractTableDetails(\n    tableNameOrModel: TableNameOrModel,\n    options?: { schema?: string, delimiter?: string },\n  ): TableNameWithSchema {\n    const tableNameObject = isModelStatic(tableNameOrModel) ? tableNameOrModel.getTableName()\n      : isString(tableNameOrModel) ? { tableName: tableNameOrModel }\n      : tableNameOrModel;\n\n    if (!isPlainObject(tableNameObject)) {\n      throw new Error(`Invalid input received, got ${NodeUtil.inspect(tableNameOrModel)}, expected a Model Class, a TableNameWithSchema object, or a table name string`);\n    }\n\n    // @ts-expect-error -- TODO: this is added by getTableName on model, and must be removed\n    delete tableNameObject.toString;\n\n    return {\n      ...tableNameObject,\n      schema: options?.schema || tableNameObject.schema || this.options.schema || this.dialect.getDefaultSchema(),\n      delimiter: options?.delimiter || tableNameObject.delimiter || '.',\n    };\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param param table string or object\n   * @param alias alias name\n   */\n  quoteTable(param: TableNameOrModel, alias: boolean | string = false): string {\n    if (isModelStatic(param)) {\n      param = param.getTableName();\n    }\n\n    const tableName = this.extractTableDetails(param);\n\n    if (isObject(param) && ('as' in param || 'name' in param)) {\n      throw new Error('parameters \"as\" and \"name\" are not allowed in the first parameter of quoteTable, pass them as the second parameter.');\n    }\n\n    if (alias === true) {\n      alias = tableName.tableName;\n    }\n\n    let sql = '';\n\n    if (this.dialect.supports.schemas) {\n      // Some users sync the same set of tables in different schemas for various reasons\n      // They then set `searchPath` when running a query to use different schemas.\n      // See https://github.com/sequelize/sequelize/pull/15274#discussion_r1020770364\n      // For this reason, we treat the default schema as equivalent to \"no schema specified\"\n      if (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema()) {\n        sql += `${this.quoteIdentifier(tableName.schema)}.`;\n      }\n\n      sql += this.quoteIdentifier(tableName.tableName);\n    } else {\n      const fakeSchemaPrefix = (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema())\n        ? tableName.schema + (tableName.delimiter || '.')\n        : '';\n\n      sql += this.quoteIdentifier(fakeSchemaPrefix + tableName.tableName);\n    }\n\n    if (alias) {\n      sql += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return sql;\n  }\n\n  /**\n   * Adds quotes to identifier\n   *\n   * @param identifier\n   * @param _force\n   */\n  quoteIdentifier(identifier: string, _force?: boolean) {\n    return quoteIdentifier(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);\n  }\n\n  isSameTable(tableA: TableNameOrModel, tableB: TableNameOrModel) {\n    if (tableA === tableB) {\n      return true;\n    }\n\n    tableA = this.extractTableDetails(tableA);\n    tableB = this.extractTableDetails(tableB);\n\n    return tableA.tableName === tableB.tableName && tableA.schema === tableB.schema;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAqB;AACrB,sBAAqB;AAGrB,mBAAwC;AACxC,qBAAgC;AAChC,yBAA8B;AAavB,MAAM,yCAAyC,oBAAI,IAAmC,CAAC,gBAAgB,YAAY,SAAS,CAAC;AAY7H,MAAM,iCAAiC;AAAA,EAEzB;AAAA,EACA;AAAA,EAEnB,YAAY,SAAgC;AAC1C,QAAI,CAAC,QAAQ,WAAW;AACtB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAEA,QAAI,CAAC,QAAQ,SAAS;AACpB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AAAA,EACzB;AAAA,EAEA,IAAc,UAAU;AACtB,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA,EAEA,mBAAmB,WAA6B;AAC9C,WAAO,YAAY,KAAK,WAAW,SAAS;AAAA,EAC9C;AAAA,EAEA,iBAAiB,YAAsC;AACrD,UAAM,IAAI,MAAM,gDAAgD,KAAK,QAAQ,OAAO;AAAA,EACtF;AAAA,EAEA,iBACE,YACA,wBACA,UACQ;AACR,UAAM,IAAI,MAAM,gDAAgD,KAAK,QAAQ,OAAO;AAAA,EACtF;AAAA;AAAA,EAGA,oBACE,kBACA,SACqB;AACrB,UAAM,sBAAkB,kCAAc,gBAAgB,IAAI,iBAAiB,aAAa,QACpF,uBAAS,gBAAgB,IAAI,EAAE,WAAW,iBAAiB,IAC3D;AAEJ,QAAI,KAAC,4BAAc,eAAe,GAAG;AACnC,YAAM,IAAI,MAAM,+BAA+B,iBAAAA,QAAS,QAAQ,gBAAgB,iFAAiF;AAAA,IACnK;AAGA,WAAO,gBAAgB;AAEvB,WAAO;AAAA,MACL,GAAG;AAAA,MACH,SAAQ,mCAAS,WAAU,gBAAgB,UAAU,KAAK,QAAQ,UAAU,KAAK,QAAQ,iBAAiB;AAAA,MAC1G,YAAW,mCAAS,cAAa,gBAAgB,aAAa;AAAA,IAChE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,OAAyB,QAA0B,OAAe;AAC3E,YAAI,kCAAc,KAAK,GAAG;AACxB,cAAQ,MAAM,aAAa;AAAA,IAC7B;AAEA,UAAM,YAAY,KAAK,oBAAoB,KAAK;AAEhD,YAAI,gBAAAC,SAAS,KAAK,MAAM,QAAQ,SAAS,UAAU,QAAQ;AACzD,YAAM,IAAI,MAAM,qHAAqH;AAAA,IACvI;AAEA,QAAI,UAAU,MAAM;AAClB,cAAQ,UAAU;AAAA,IACpB;AAEA,QAAI,MAAM;AAEV,QAAI,KAAK,QAAQ,SAAS,SAAS;AAKjC,UAAI,UAAU,UAAU,UAAU,WAAW,KAAK,QAAQ,iBAAiB,GAAG;AAC5E,eAAO,GAAG,KAAK,gBAAgB,UAAU,MAAM;AAAA,MACjD;AAEA,aAAO,KAAK,gBAAgB,UAAU,SAAS;AAAA,IACjD,OAAO;AACL,YAAM,mBAAoB,UAAU,UAAU,UAAU,WAAW,KAAK,QAAQ,iBAAiB,IAC7F,UAAU,UAAU,UAAU,aAAa,OAC3C;AAEJ,aAAO,KAAK,gBAAgB,mBAAmB,UAAU,SAAS;AAAA,IACpE;AAEA,QAAI,OAAO;AACT,aAAO,OAAO,KAAK,gBAAgB,KAAK;AAAA,IAC1C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBAAgB,YAAoB,QAAkB;AACpD,eAAO,gCAAgB,YAAY,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,eAAe;AAAA,EAC9F;AAAA,EAEA,YAAY,QAA0B,QAA0B;AAC9D,QAAI,WAAW,QAAQ;AACrB,aAAO;AAAA,IACT;AAEA,aAAS,KAAK,oBAAoB,MAAM;AACxC,aAAS,KAAK,oBAAoB,MAAM;AAExC,WAAO,OAAO,cAAc,OAAO,aAAa,OAAO,WAAW,OAAO;AAAA,EAC3E;AACF;",
  "names": ["NodeUtil", "isObject"]
}
