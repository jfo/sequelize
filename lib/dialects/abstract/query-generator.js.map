{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport NodeUtil from 'node:util';\nimport { conformIndex } from '../../model-internals';\nimport { getTextDataTypeForDialect } from '../../sql-string';\nimport { rejectInvalidOptions, isNullish, canTreatArrayAsAnd, isColString } from '../../utils/check';\nimport { TICK_CHAR } from '../../utils/dialect';\nimport {\n  getComplexKeys,\n  getComplexSize,\n  getOperators,\n  mapFinderOptions,\n  removeNullishValuesFromHash,\n} from '../../utils/format';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments';\nimport { isModelStatic } from '../../utils/model-utils';\nimport { Cast, Col, Fn, Literal, SequelizeMethod, Where } from '../../utils/sequelize-method';\nimport { injectReplacements } from '../../utils/sql';\nimport { nameIndex, spliceStr } from '../../utils/string';\nimport { AbstractDataType } from './data-types';\nimport { attributeTypeToSql, validateDataType } from './data-types-utils';\nimport { AbstractQueryGeneratorTypeScript } from './query-generator-typescript';\n\nconst util = require('node:util');\nconst _ = require('lodash');\nconst crypto = require('node:crypto');\n\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst { Model } = require('../../model');\nconst { Association } = require('../../associations/base');\nconst { BelongsTo } = require('../../associations/belongs-to');\nconst { BelongsToMany } = require('../../associations/belongs-to-many');\nconst { HasMany } = require('../../associations/has-many');\nconst { Op } = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst { IndexHints } = require('../../index-hints');\nconst { _validateIncludedElements } = require('../../model-internals');\n\n/**\n * List of possible options listed in {@link CreateDatabaseQueryOptions}.\n * It is used to validate the options passed to {@link QueryGenerator#createDatabaseQuery},\n * as not all of them are supported by all dialects.\n */\nexport const CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS = new Set(['collate', 'charset', 'encoding', 'ctype', 'template']);\nexport const CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS = new Set(['collate', 'charset']);\nexport const LIST_SCHEMAS_QUERY_SUPPORTABLE_OPTIONS = new Set(['skip']);\nexport const DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS = new Set(['cascade']);\nexport const ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS = new Set(['ifNotExists']);\nexport const REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS = new Set(['ifExists']);\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nexport class AbstractQueryGenerator extends AbstractQueryGeneratorTypeScript {\n  createDatabaseQuery() {\n    if (this.dialect.supports.multiDatabases) {\n      throw new Error(`${this.dialect.name} declares supporting databases but createDatabaseQuery is not implemented.`);\n    }\n\n    throw new Error(`Databases are not supported in ${this.dialect.name}.`);\n  }\n\n  dropDatabaseQuery() {\n    if (this.dialect.supports.multiDatabases) {\n      throw new Error(`${this.dialect.name} declares supporting databases but dropDatabaseQuery is not implemented.`);\n    }\n\n    throw new Error(`Databases are not supported in ${this.dialect.name}.`);\n  }\n\n  listDatabasesQuery() {\n    if (this.dialect.supports.multiDatabases) {\n      throw new Error(`${this.dialect.name} declares supporting databases but listDatabasesQuery is not implemented.`);\n    }\n\n    throw new Error(`Databases are not supported in ${this.dialect.name}.`);\n  }\n\n  createSchemaQuery() {\n    if (this.dialect.supports.schemas) {\n      throw new Error(`${this.dialect.name} declares supporting schema but createSchemaQuery is not implemented.`);\n    }\n\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  dropSchemaQuery() {\n    if (this.dialect.supports.schemas) {\n      throw new Error(`${this.dialect.name} declares supporting schema but dropSchemaQuery is not implemented.`);\n    }\n\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  listSchemasQuery() {\n    if (this.dialect.supports.schemas) {\n      throw new Error(`${this.dialect.name} declares supporting schema but listSchemasQuery is not implemented.`);\n    }\n\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  dropTableQuery(tableName, options) {\n    const DROP_TABLE_QUERY_SUPPORTED_OPTIONS = new Set();\n\n    if (options) {\n      rejectInvalidOptions(\n        'dropTableQuery',\n        this.dialect.name,\n        DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        DROP_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {object} valueHash       attribute value pairs\n   * @param {object} modelAttributes\n   * @param {object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const bind = Object.create(null);\n    const fields = [];\n    const returningModelAttributes = [];\n    const values = Object.create(null);\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let returningFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = ''; // tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this.dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this.dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this.dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n\n      returningModelAttributes.push(...returnValues.returnFields);\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this.dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = removeNullishValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this.dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this.dialect.supports.DEFAULT) {\n            values[key] = 'DEFAULT';\n          } else {\n            values[key] = this.escape(null);\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof SequelizeMethod || options.bindParam === false) {\n            values[key] = this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT', replacements: options.replacements });\n          } else {\n            values[key] = this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam);\n          }\n        }\n      }\n    }\n\n    let onDuplicateKeyUpdate = '';\n\n    if (\n      !_.isEmpty(options.conflictWhere)\n      && !this.dialect.supports.inserts.onConflictWhere\n    ) {\n      throw new Error('missing dialect support for conflictWhere option');\n    }\n\n    // `options.updateOnDuplicate` is the list of field names to update if a duplicate key is hit during the insert.  It\n    // contains just the field names.  This option is _usually_ explicitly set by the corresponding query-interface\n    // upsert function.\n    if (this.dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this.dialect.supports.inserts.updateOnDuplicate === ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n\n        const fragments = [\n          'ON CONFLICT',\n          '(',\n          conflictKeys.join(','),\n          ')',\n        ];\n\n        if (!_.isEmpty(options.conflictWhere)) {\n          fragments.push(this.whereQuery(options.conflictWhere, options));\n        }\n\n        // if update keys are provided, then apply them here.  if there are no updateKeys provided, then do not try to\n        // do an update.  Instead, fall back to DO NOTHING.\n        if (_.isEmpty(updateKeys)) {\n          fragments.push('DO NOTHING');\n        } else {\n          fragments.push('DO UPDATE SET', updateKeys.join(','));\n        }\n\n        onDuplicateKeyUpdate = ` ${joinSQLFragments(fragments)}`;\n      } else {\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=${values[attr]}`);\n        // the rough equivalent to ON CONFLICT DO NOTHING in mysql, etc is ON DUPLICATE KEY UPDATE id = id\n        // So, if no update values were provided, fall back to the identifier columns provided in the upsertKeys array.\n        // This will be the primary key in most cases, but it could be some other constraint.\n        if (_.isEmpty(valueKeys) && options.upsertKeys) {\n          valueKeys.push(...options.upsertKeys.map(attr => `${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));\n        }\n\n        // edge case... but if for some reason there were no valueKeys, and there were also no upsertKeys... then we\n        // can no longer build the requested query without a syntax error.  Let's throw something more graceful here\n        // so the devs know what the problem is.\n        if (_.isEmpty(valueKeys)) {\n          throw new Error('No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.');\n        }\n\n        onDuplicateKeyUpdate += `${this.dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this.dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this.dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: Object.values(values).join(','),\n      tmpTable,\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    // Mostly for internal use, so we expect the user to know what he's doing!\n    // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n    if (this.dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push('*');\n      }\n\n      const delimiter = `$func_${crypto.randomUUID().replace(/-/g, '')}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n\n      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n\n    query = `${`${replacements.attributes.length > 0 ? valueQuery : emptyQuery}`.trim()};`;\n    if (this.dialect.supports.finalTable) {\n      query = `SELECT * FROM FINAL TABLE (${replacements.attributes.length > 0 ? valueQuery : emptyQuery});`;\n    }\n\n    if (identityWrapperRequired && this.dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this.dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          // fieldValueHashes[key] ?? 'DEFAULT'\n          return fieldValueHash[key] != null ? fieldValueHash[key] : 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT', replacements: options.replacements });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    // `options.updateOnDuplicate` is the list of field names to update if a duplicate key is hit during the insert.  It\n    // contains just the field names.  This option is _usually_ explicitly set by the corresponding query-interface\n    // upsert function.\n    if (this.dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this.dialect.supports.inserts.updateOnDuplicate === ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n\n        let whereClause = false;\n        if (options.conflictWhere) {\n          if (!this.dialect.supports.inserts.onConflictWhere) {\n            throw new Error(`conflictWhere not supported for dialect ${this.dialect.name}`);\n          }\n\n          whereClause = this.whereQuery(options.conflictWhere, options);\n        }\n\n        // The Utils.joinSQLFragments later on will join this as it handles nested arrays.\n        onDuplicateKeyUpdate = [\n          'ON CONFLICT',\n          '(',\n          conflictKeys.join(','),\n          ')',\n          whereClause,\n          'DO UPDATE SET',\n          updateKeys.join(','),\n        ];\n      } else { // mysql / maria\n        if (options.conflictWhere) {\n          throw new Error(`conflictWhere not supported for dialect ${this.dialect.name}`);\n        }\n\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this.dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this.dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this.dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this.dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n\n      returning += returnValues.returningFragment;\n    }\n\n    return joinSQLFragments([\n      'INSERT',\n      ignoreDuplicates,\n      'INTO',\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      'VALUES',\n      tuples.join(','),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      ';',\n    ]);\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {object} attrValueHash\n   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} options\n   * @param {object} columnDefinitions\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, columnDefinitions) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = removeNullishValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = Object.create(null);\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = ''; // tmpTable declaration for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this.dialect.supports['LIMIT ON UPDATE'] && options.limit && this.dialect.name !== 'mssql' && this.dialect.name !== 'db2') {\n      suffix = ` LIMIT ${this.escape(options.limit, undefined, options)} `;\n    }\n\n    if (this.dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(columnDefinitions, options);\n\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n\n      // ensure that the return output is properly mapped to model fields.\n      if (this.dialect.supports.returnValues !== 'output' && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n\n    if (columnDefinitions) {\n      _.each(columnDefinitions, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key]\n        && modelAttributeMap[key].autoIncrement === true\n        && !this.dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE', replacements: options.replacements })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = { ...options, bindParam };\n\n    if (values.length === 0) {\n      return { query: '' };\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName                   Name of the table\n   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs\n   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs\n   * @param {object} options\n   *\n   * @private\n   */\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    // TODO: this method should delegate to `updateQuery`\n\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    const replacementOptions = _.pick(options, ['replacements']);\n\n    extraAttributesToBeUpdated = removeNullishValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this.dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount, undefined, replacementOptions);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue, undefined, replacementOptions);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n\n    return joinSQLFragments([\n      'UPDATE',\n      this.quoteTable(tableName),\n      'SET',\n      updateSetSqlFragments.join(','),\n      outputFragment,\n      this.whereQuery(where, replacementOptions),\n      returningFragment,\n    ]);\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n        - include\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (field instanceof SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n\n      if (typeof field === 'string') {\n        field = {\n          name: field,\n        };\n      }\n\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this.dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this.dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n\n      if (this.dialect.supports.index.length > 0 && field.length > 0) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    let includeSql;\n    if (options.include) {\n      if (!this.dialect.supports.index.include) {\n        throw new Error(`The include attribute for indexes is not supported by ${this.dialect.name} dialect`);\n      }\n\n      if (options.include instanceof Literal) {\n        includeSql = `INCLUDE ${options.include.val}`;\n      } else if (Array.isArray(options.include)) {\n        includeSql = `INCLUDE (${options.include.map(field => (field instanceof Literal ? field.val : this.quoteIdentifier(field))).join(', ')})`;\n      } else {\n        throw new TypeError('The include attribute for indexes must be an array or a literal.');\n      }\n    }\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = nameIndex(options, options.prefix);\n    }\n\n    options = conformIndex(options);\n\n    if (!this.dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    const escapedTableName = this.quoteTable(tableName);\n\n    const concurrently = this.dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this.dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        escapedTableName,\n        concurrently,\n        'ADD',\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    // DB2 incorrectly scopes the index if we don't specify the schema name,\n    // which will cause it to error if another schema contains a table that uses an index with an identical name\n    const escapedIndexName = tableName.schema && this.dialect.name === 'db2'\n      // 'quoteTable' isn't the best name: it quotes any identifier.\n      // in this case, the goal is to produce '\"schema_name\".\"index_name\"' to scope the index in this schema\n      ? this.quoteTable({\n        schema: tableName.schema,\n        tableName: options.name,\n      })\n      : this.quoteIdentifiers(options.name);\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this.dialect.supports.indexViaAlter ? concurrently : undefined,\n      escapedIndexName,\n      this.dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this.dialect.supports.indexViaAlter ? `ON ${escapedTableName}` : undefined,\n      this.dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')})`,\n      this.dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this.dialect.supports.index.include && options.include ? includeSql : undefined,\n      this.dialect.supports.index.where && options.where ? options.where : undefined,\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'ADD',\n      this.getConstraintSnippet(tableName, options || {}),\n      ';',\n    ]);\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet;\n    let constraintName;\n\n    const quotedFields = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n\n      if (field instanceof SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const constraintNameParts = options.name ? null : options.fields.map(field => {\n      if (typeof field === 'string') {\n        return field;\n      }\n\n      if (field instanceof SequelizeMethod) {\n        throw new TypeError(`The constraint name must be provided explicitly if one of Sequelize's method (literal(), col(), etc\u2026) is used in the constraint's fields`);\n      }\n\n      if (field.attribute) {\n        return field.attribute;\n      }\n\n      return field.name;\n    });\n\n    const fieldsSqlQuotedString = quotedFields.join(', ');\n    const fieldsSqlString = constraintNameParts?.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specified for DEFAULT CONSTRAINT');\n        }\n\n        if (this.dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue, undefined, options)}) FOR ${quotedFields[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY': {\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error('references object with table and field must be specified');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences\n          = typeof references.field !== 'undefined'\n          ? this.quoteIdentifier(references.field)\n          : references.fields.map(f => this.quoteIdentifier(f)).join(', ');\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          if (!this.dialect.supports.constraints.onUpdate) {\n            throw new Error(`Constraint onUpdate is not supported by ${this.dialect.name}`);\n          }\n\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n\n        break;\n      }\n\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n\n    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifiers(constraintName),\n    ]);\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector = '.', options) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST',\n    ];\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (isModelStatic(previousModel)) {\n          let model;\n          let as;\n\n          if (isModelStatic(item)) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && isModelStatic(item.model)) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through?.model === model) {\n              // we get here for cases like\n              // [manyToManyAssociation, throughModel]\n              // \"throughModel\" must be replaced by the association from the many to many to the through model\n              item = previousAssociation.fromSourceToThroughOne;\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationWithModel(model, as);\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new TypeError(`Unable to find a valid association between models \"${previousModel.name}\" and \"${model.name}\"`);\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (isModelStatic(previousModel)) {\n            const { modelDefinition: previousModelDefinition } = previousModel;\n\n            // only go down this path if we have previous model and check only once\n            if (previousModel.associations?.[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModelDefinition.attributes.has(item)) {\n              // convert the item attribute from its alias\n              item = previousModelDefinition.attributes.get(item).columnName;\n            } else if (\n              item.includes('.')\n            ) {\n              const itemSplit = item.split('.');\n\n              const jsonAttribute = previousModelDefinition.attributes.get(itemSplit[0]);\n              if (jsonAttribute.type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${jsonAttribute.columnName}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      });\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          const previousAssociation = collection[i - 1];\n\n          // BelongsToMany.throughModel are a special case. We want\n          //  through model to be loaded under the model's name instead of the association name,\n          //  because we want them to be available under the model's name in the entity's data.\n          if (previousAssociation instanceof BelongsToMany && item === previousAssociation.fromSourceToThroughOne) {\n            tableNames[i] = previousAssociation.throughModel.name;\n          } else {\n            tableNames[i] = item.as;\n          }\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      for (const collectionItem of collection.slice(i)) {\n        sql += this.quote(collectionItem, parent, connector, options);\n      }\n\n      return sql;\n    }\n\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n\n    if (collection instanceof SequelizeMethod) {\n      return this.handleSequelizeMethod(collection, undefined, undefined, options);\n    }\n\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * \u26A0\uFE0F You almost certainly want to use `quoteIdentifier` instead!\n   * This method splits the identifier by \".\" into multiple identifiers, and has special meaning for \"*\".\n   * This behavior should never be the default and should be explicitly opted into by using {@link Col}.\n   *\n   * @param {string} identifiers\n   *\n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, -1).join('->');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${tail === '*' ? '*' : this.quoteIdentifier(tail)}`;\n    }\n\n    if (identifiers === '*') {\n      return '*';\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  /**\n   * Escape a value (e.g. a string, number or date)\n   *\n   * @param {unknown} value\n   * @param {object} attribute\n   * @param {object} options\n   * @private\n   */\n  escape(value, attribute, options = {}) {\n    if (value instanceof SequelizeMethod) {\n      return this.handleSequelizeMethod(value, undefined, undefined, { replacements: options.replacements });\n    }\n\n    if (value == null || attribute?.type == null || typeof attribute.type === 'string') {\n      // use default escape mechanism instead of the DataType's.\n      return SqlString.escape(value, this.options.timezone, this.dialect);\n    }\n\n    if (!attribute.type.belongsToDialect(this.dialect)) {\n      attribute = {\n        ...attribute,\n        type: attribute.type.toDialectDataType(this.dialect),\n      };\n    }\n\n    if (options.isList && Array.isArray(value)) {\n      const escapeOptions = { ...options, isList: false };\n\n      return `(${value.map(valueItem => {\n        return this.escape(valueItem, attribute, escapeOptions);\n      }).join(', ')})`;\n    }\n\n    this.validate(value, attribute, options);\n\n    return attribute.type.escape(value, {\n      field: attribute,\n      timezone: this.options.timezone,\n      operation: options.operation,\n      dialect: this.dialect,\n    });\n  }\n\n  bindParam(bind) {\n    let i = 0;\n\n    return value => {\n      const bindName = `sequelize_${++i}`;\n\n      bind[bindName] = value;\n\n      return `$${bindName}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value instanceof SequelizeMethod) {\n      throw new TypeError('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n    }\n\n    if (value == null || !field?.type || typeof field.type === 'string') {\n      return bindParam(value);\n    }\n\n    this.validate(value, field, options);\n\n    return field.type.getBindParamSql(value, {\n      field,\n      timezone: this.options.timezone,\n      operation: options.operation,\n      bindParam,\n      dialect: this.dialect,\n    });\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field) {\n    if (this.noTypeValidation || isNullish(value)) {\n      return;\n    }\n\n    const error = field.type instanceof AbstractDataType\n      ? validateDataType(field.type, field.fieldName, null, value)\n      : null;\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * @param {string} identifier\n   *\n   * @deprecated Do not use this method. A string starting & ending with the identifier quote (\", `, []) does\n   * not mean that it's already quoted. These characters are valid inside of identifiers and should be properly escaped.\n   */\n  isIdentifierQuoted(identifier) {\n    return /^\\s*(?:([\"'`])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               _column   The JSON column\n   * @param   {string|Array<string>} [_path]   The path to extract (optional)\n   * @param   {boolean}              [_isJson] The value is JSON use alt symbols (optional)\n   * @returns {string}                         The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(_column, _path, _isJson) {\n    throw new Error(`JSON operations are not supported in ${this.dialect.name}.`);\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && [...options.attributes],\n      subQuery: null,\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      quotedAs: null,\n      model,\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery,\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // Aliases can be passed through subqueries and we don't want to reset them\n    if (options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = new Map();\n    }\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = options.tableAs;\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = mainTable.model.name;\n    }\n\n    mainTable.quotedAs = mainTable.as && this.quoteIdentifier(mainTable.as);\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    const mainModelDefinition = mainTable.model?.modelDefinition;\n    const mainModelAttributes = mainModelDefinition?.attributes;\n\n    if (subQuery && attributes.main) {\n      for (const pkAttrName of mainModelDefinition.primaryKeysAttributeNames) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => pkAttrName === attr || pkAttrName === attr[0] || pkAttrName === attr[1])) {\n          const attribute = mainModelAttributes.get(pkAttrName);\n          attributes.main.push(attribute.columnName !== pkAttrName ? [pkAttrName, attribute.columnName] : pkAttrName);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.quotedAs}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.quotedAs || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo, { replacements: options.replacements, minifyAliases: options.minifyAliases });\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(\n        this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.quotedAs),\n        subJoinQueries.join(''),\n      );\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.quotedAs) {\n          mainTable.quotedAs = mainTable.quotedName;\n        }\n\n        if (!mainTable.as) {\n          mainTable.as = mainTable.name;\n        }\n\n        const where = { ...options.where };\n        let groupedLimitOrder;\n        let whereKey;\n        let include;\n        let groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.identifierField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.throughModel.name;\n\n          const groupedLimitOptions = _validateIncludedElements({\n            include: [{\n              as: options.groupedLimit.on.throughModel.name,\n              association: options.groupedLimit.on.fromSourceToThrough,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: {\n                [Op.placeholder]: true,\n                ...options.groupedLimit.through?.where,\n              },\n            }],\n            model,\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias, undefined, undefined, options));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            minifyAliases: options.minifyAliases,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where,\n            include,\n            model,\n          },\n          model,\n        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value,\n              };\n            }\n\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value,\n              };\n            }\n\n            return spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName, undefined, options));\n          }).join(\n            this.dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION ',\n          )\n        })`, mainTable.quotedAs));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.quotedAs));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          for (const [key, value] of mainQueryItems.entries()) {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.quotedAs, options.where);\n            }\n          }\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group)\n        ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ')\n        : this.aliasGrouping(options.group, model, mainTable.as, options);\n\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length > 0) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n\n      if (orders.subQueryOrder.length > 0) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.quotedAs });\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.quotedAs}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this.dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n\n      if (this.dialect.supports.lockKey && ['KEY SHARE', 'NO KEY UPDATE'].includes(lock)) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this.dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n\n      if (this.dialect.supports.lockOf && options.lock.of && isModelStatic(options.lock.of)) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n\n      if (this.dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model, undefined, options);\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    const quotedMainTableAs = mainTableAs && this.quoteIdentifier(mainTableAs);\n\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof SequelizeMethod) {\n        return this.handleSequelizeMethod(attr, undefined, undefined, options);\n      }\n\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n\n        attr = [...attr];\n\n        if (attr[0] instanceof SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0], undefined, undefined, options);\n          addTable = false;\n        } else {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        }\n\n        let alias = attr[1];\n\n        if (options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n\n        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');\n      } else {\n        attr = this.quoteIdentifier(attr, options.model);\n      }\n\n      if (!_.isEmpty(options.include) && (!attr.includes('.') || options.dotNotation) && addTable) {\n        attr = `${quotedMainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo, options) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: [],\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as,\n    };\n    const attributes = {\n      main: [],\n      subQuery: [],\n    };\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      mapFinderOptions(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof SequelizeMethod && (\n            attr[0] instanceof Literal\n            || attr[0] instanceof Cast\n            || attr[0] instanceof Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attrPart => (attrPart instanceof SequelizeMethod ? this.handleSequelizeMethod(attrPart, undefined, undefined, options) : attrPart));\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n\n        if (attr instanceof Literal) {\n          // We trust the user to rename the field correctly\n          return this.handleSequelizeMethod(attr, undefined, undefined, options);\n        }\n\n        if (attr instanceof Cast || attr instanceof Fn) {\n          throw new TypeError(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. '\n            + 'This means the attribute will not be added to the returned instance',\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n\n        if (options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n\n        return joinSQLFragments([\n          prefix,\n          'AS',\n          this.quoteIdentifier(alias, true),\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    let joinQuery;\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo, { minifyAliases: options.minifyAliases });\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo, options);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo, options);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes,\n    };\n  }\n\n  _getMinifiedAlias(alias, tableName, options) {\n    // We do not want to re-alias in case of a subquery\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n\n    // Do not alias custom suquery_orders\n    if (/subquery_order_\\d/.test(alias)) {\n      return alias;\n    }\n\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n\n    return minifiedAlias;\n  }\n\n  _getAliasForField(tableName, field, options) {\n    if (options.minifyAliases && options.aliasesByTable[`${tableName}${field}`]) {\n      return options.aliasesByTable[`${tableName}${field}`];\n    }\n\n    return null;\n  }\n\n  _getAliasForFieldFromQueryOptions(field, options) {\n    return (options.attributes || []).find(\n      attr => Array.isArray(attr) && attr[1] && (attr[0] === field || attr[1] === field),\n    );\n  }\n\n  generateJoin(include, topLevelInfo, options) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = Boolean(parent) && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const leftAttributes = left.modelDefinition.attributes;\n\n    const attrNameLeft = association instanceof BelongsTo\n      ? association.foreignKey\n      : association.sourceKeyAttribute;\n    const columnNameLeft = association instanceof BelongsTo\n      ? association.identifierField\n      : leftAttributes.get(association.sourceKeyAttribute).columnName;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const rightAttributes = right.modelDefinition.attributes;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo\n      ? rightAttributes.get(association.targetKey).columnName\n      : association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) {\n      asLeft = parent.as || parent.model.name;\n    } else {\n      asRight = `${asLeft}->${asRight}`;\n    }\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(columnNameLeft)}`;\n    const subqueryAttributes = [];\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        const tableName = parent.as || parent.model.name;\n        const quotedTableName = this.quoteTable(tableName);\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(tableName, attrNameLeft, topLevelInfo.options) || `${quotedTableName}.${this.quoteIdentifier(attrNameLeft)}`;\n\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${quotedTableName}.${this.quoteIdentifier(columnNameLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrNameLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrNameLeft}`;\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model,\n        replacements: options?.replacements,\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model,\n        replacements: options?.replacements,\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    if (options?.minifyAliases && asRight.length > 63) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n\n      topLevelInfo.options.includeAliases.set(alias, asRight);\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : include.right && this.dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes,\n      },\n    };\n  }\n\n  /**\n   * Returns the SQL fragments to handle returning the attributes from an insert/update query.\n   *\n   * @param  {object} modelAttributes An object with the model attributes.\n   * @param  {object} options         An object with options.\n   *\n   * @private\n   */\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = '';\n    let returningFragment = '';\n    let tmpTable = '';\n\n    const returnValuesType = this.dialect.supports.returnValues;\n\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map(field => {\n        if (typeof field === 'string') {\n          return this.quoteIdentifier(field);\n        } else if (field instanceof Literal) {\n          // Due to how the mssql query is built, using a literal would never result in a properly formed query.\n          // It's better to warn early.\n          if (returnValuesType === 'output') {\n            throw new Error(`literal() cannot be used in the \"returning\" option array in ${this.dialect.name}. Use col(), or a string instead.`);\n          }\n\n          return this.handleSequelizeMethod(field);\n        } else if (field instanceof Col) {\n          return this.handleSequelizeMethod(field);\n        }\n\n        throw new Error(`Unsupported value in \"returning\" option: ${NodeUtil.inspect(field)}. This option only accepts true, false, or an array of strings, col() or literal().`);\n      }));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, attribute => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n\n    if (_.isEmpty(returnFields)) {\n      returnFields.push(`*`);\n    }\n\n    if (returnValuesType === 'returning') {\n      returningFragment = ` RETURNING ${returnFields.join(', ')}`;\n    } else if (returnValuesType === 'output') {\n      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(', ')}`;\n\n      // To capture output rows when there is a trigger on MSSQL DB\n      if (options.hasTrigger && this.dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => {\n          return `${field} ${attributeTypeToSql(returnTypes[i], { dialect: this.dialect })}`;\n        });\n\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;\n        outputFragment += ' INTO @tmp';\n        returningFragment = '; SELECT * FROM @tmp';\n      }\n    }\n\n    return { outputFragment, returnFields, returningFragment, tmpTable };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo, options) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n\n    const throughAttributes = through.attributes.map(attr => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n\n      if (options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n\n      return joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        'AS',\n        this.quoteIdentifier(alias),\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : include.right && this.dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: [],\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (options.minifyAliases && throughAs.length > 63) {\n      topLevelInfo.options.includeAliases.set(`%${topLevelInfo.options.includeAliases.size}`, throughAs);\n      if (includeAs.internalAs.length > 63) {\n        topLevelInfo.options.includeAliases.set(`%${topLevelInfo.options.includeAliases.size}`, includeAs.internalAs);\n      }\n    }\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model, topLevelInfo.options);\n    }\n\n    // Generate a wrapped join so that the through table join can be dependent on the target join\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n\n    joinBody += ')';\n    joinCondition = sourceJoinOn;\n\n    if ((include.where || include.through.where) && include.where) {\n      targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n      if (targetWhere) {\n        joinCondition += ` AND ${targetWhere}`;\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes,\n    };\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) {\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: _validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.fromThroughToTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include,\n          }],\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`,\n            ].join(' = ')),\n            topInclude.through.where,\n          ],\n        },\n        limit: 1,\n        includeIgnoreAttributes: false,\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`,\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: _validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) },\n          ],\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false,\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL',\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = { ...include, attributes: [], include: [] };\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !isModelStatic(order[0])\n          && !isModelStatic(order[0].model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          // TODO - refactor this.quote() to not change the first argument\n          const columnName = model.modelDefinition.getColumnNameLoose(order[0]);\n          const subQueryAlias = this._getAliasForField(model.name, columnName, options);\n\n          let parent = null;\n          let orderToQuote = [];\n\n          // we need to ensure that the parent is null if we use the subquery alias, else we'll get an exception since\n          // \"model_name\".\"alias\" doesn't exist - only \"alias\" does. we also need to ensure that we preserve order direction\n          // by pushing order[1] to the subQueryOrder as well - in case it doesn't exist, we want to push \"ASC\"\n          if (subQueryAlias === null) {\n            orderToQuote = order;\n            parent = model;\n          } else {\n            orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : 'ASC'];\n            parent = null;\n          }\n\n          subQueryOrder.push(this.quote(orderToQuote, parent, '->', options));\n        }\n\n        // Handle case where renamed attributes are used to order by,\n        // see https://github.com/sequelize/sequelize/issues/8739\n        // need to check if either of the attribute options match the order\n        if (options.attributes && model) {\n          const aliasedAttribute = this._getAliasForFieldFromQueryOptions(order[0], options);\n\n          if (aliasedAttribute) {\n            const alias = this._getAliasForField(model.name, aliasedAttribute[1], options);\n\n            order[0] = new Col(alias || aliasedAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->', options));\n      }\n    } else if (options.order instanceof SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->', options);\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n\n      mainQueryOrder.push(sql);\n    } else {\n      throw new TypeError('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0) {\n      return;\n    }\n\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this.dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {object} options An object with selectQuery options.\n   * @param {ModelStatic} model\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    if (options.limit != null) {\n      fragment += ` LIMIT ${this.escape(options.limit, undefined, options)}`;\n    } else if (options.offset) {\n      // limit must be specified if offset is specified.\n      fragment += ` LIMIT 18446744073709551615`;\n    }\n\n    if (options.offset) {\n      fragment += ` OFFSET ${this.escape(options.offset, undefined, options)}`;\n    }\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        if (value === 'NULL') {\n          if (smth.comparator === '=') {\n            smth.comparator = 'IS';\n          }\n\n          if (smth.comparator === '!=') {\n            smth.comparator = 'IS NOT';\n          }\n        }\n\n        return [key, value].join(` ${smth.comparator} `);\n      }\n\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory,\n        });\n      }\n\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0], undefined, options)} AND ${this.escape(value[1], undefined, options)}`;\n      } else if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value, undefined, options);\n      }\n\n      if (value === 'NULL') {\n        if (smth.comparator === '=') {\n          smth.comparator = 'IS';\n        }\n\n        if (smth.comparator === '!=') {\n          smth.comparator = 'IS NOT';\n        }\n      }\n\n      return [key, value].join(` ${smth.comparator} `);\n    }\n\n    if (smth instanceof Literal) {\n      if (options?.replacements) {\n        return injectReplacements(smth.val, this.dialect, options.replacements, {\n          onPositionalReplacement: () => {\n            throw new TypeError(`The following literal includes positional replacements (?).\nOnly named replacements (:name) are allowed in literal() because we cannot guarantee the order in which they will be evaluated:\n\u279C literal(${JSON.stringify(smth.val)})`);\n          },\n        });\n      }\n\n      return smth.val;\n\n    }\n\n    if (smth instanceof Cast) {\n      if (smth.val instanceof SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val, undefined, options);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n\n    if (smth instanceof Fn) {\n      return `${smth.fn}(${\n        smth.args.map(arg => {\n          if (arg instanceof SequelizeMethod) {\n            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n          }\n\n          if (_.isPlainObject(arg)) {\n            return this.whereItemsQuery(arg);\n          }\n\n          return this.escape(arg, undefined, options);\n        }).join(', ')\n      })`;\n    }\n\n    if (smth instanceof Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n\n      return this.quote(smth.col, factory, undefined, options);\n    }\n\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length > 0) {\n      return `WHERE ${query}`;\n    }\n\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null\n      || where === undefined\n      || getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new TypeError('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') {\n      binding = ` ${binding} `;\n    }\n\n    if (_.isPlainObject(where)) {\n      for (const prop of getComplexKeys(where)) {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      }\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      const { attributes } = options.model.modelDefinition;\n      const attribute = attributes.get(keyParts[0]);\n      if (attribute?.type instanceof DataTypes.JSON) {\n        const tmp = {};\n        _.set(tmp, keyParts.slice(1), value);\n\n        return this.whereItemQuery(attribute.columnName, tmp, { field: attribute, ...options });\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n\n    const valueKeys = isPlainObject && getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field, options);\n\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field, options);\n\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof SequelizeMethod && !(key !== undefined && value instanceof Fn)) {\n      return this.handleSequelizeMethod(value, undefined, undefined, options);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field, options);\n\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field, options);\n\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field, options);\n\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    const modelDefinition = options.model?.modelDefinition;\n    const attribute = modelDefinition?.attributes.get(key);\n    if (attribute) {\n      return attribute;\n    }\n\n    const column = modelDefinition?.columns.get(key);\n    if (column) {\n      return column;\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length > 0 && (Array.isArray(item) || _.isPlainObject(item)) && getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = getComplexKeys(value).map(prop => {\n        const item = value[prop];\n\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length > 0 ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    for (const op of getOperators(value)) {\n      const where = {\n        [op]: value[op],\n      };\n      items.push(this.whereItemQuery(key, where, { ...options, json: false }));\n    }\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    let pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      for (const op of getOperators(item)) {\n        const value = this._toJSONValue(item[op]);\n        let isJson = false;\n        if (typeof value === 'string' && op === Op.contains) {\n          try {\n            JSON.stringify(value);\n            isJson = true;\n          } catch {\n            // failed to parse, is not json so isJson remains false\n          }\n        }\n\n        pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      }\n\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, [...path, itemProp]);\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Literal(this.handleSequelizeMethod(new Cast(new Literal(key), cast, json)));\n    }\n\n    return new Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n\n    key = this._getSafeKey(key, prefix);\n\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (isColString(key)) {\n      key = key.slice(1, 1 + key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1],\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length > 0) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field, { where: true, replacements: options.replacements })).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item, undefined, options)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field, options)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field, options)} AND ${this.escape(value[1], field, options)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1],\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n      case Op.notStartsWith:\n      case Op.notEndsWith:\n      case Op.notSubstring: {\n        if (comparator !== this.OperatorMap[Op.like]) {\n          comparator = this.OperatorMap[Op.notLike];\n        }\n\n        if (value instanceof Literal) {\n          value = value.val;\n        }\n\n        let pattern = `${value}%`;\n\n        if (prop === Op.endsWith || prop === Op.notEndsWith) {\n          pattern = `%${value}`;\n        }\n\n        if (prop === Op.substring || prop === Op.notSubstring) {\n          pattern = `%${value}%`;\n        }\n\n        return this._joinKeyValue(key, this.escape(pattern, undefined, options), comparator, options.prefix);\n      }\n\n      case Op.anyKeyExists:\n      case Op.allKeysExist: {\n        if (value instanceof SequelizeMethod) {\n          return this._joinKeyValue(key, this.handleSequelizeMethod(value, undefined, undefined, options), comparator, options.prefix);\n        }\n\n        if (value.length === 0) {\n          return this._joinKeyValue(key, `ARRAY[]::text[]`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `ARRAY[${value.map(item => this.escape(item, undefined, options)).join(', ')}]`, comparator, options.prefix);\n      }\n    }\n\n    const escapeOptions = {\n      replacements: options.replacements,\n    };\n\n    // because UUID is implemented as CHAR() in most dialects (except postgres)\n    //  we accept comparing to non-uuid values when using LIKE and similar operators.\n    // TODO: https://github.com/sequelize/sequelize/issues/13828 - in postgres, automatically cast to CHAR(36)\n    //  to have the same behavior as the others dialects.\n    if (comparator.includes(this.OperatorMap[Op.like]) && field?.type) {\n      field = {\n        ...field,\n        // replace DataType with DataTypes.TEXT() to accept all string values.\n        type: getTextDataTypeForDialect(this.dialect),\n      };\n    }\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    // In postgres, Op.contains has multiple signatures:\n    // - RANGE<VALUE> Op.contains RANGE<VALUE> (both represented by fixed-size arrays in JS)\n    // - RANGE<VALUE> Op.contains VALUE\n    // - ARRAY<VALUE> Op.contains ARRAY<VALUE>\n    // Since the left operand is a RANGE, the type validation must allow the right operand to be either RANGE or VALUE.\n    if (prop === Op.contains && field?.type instanceof DataTypes.RANGE && !Array.isArray(value)) {\n      // Since the right operand is not an array, it must be a value.\n      // We'll serialize using the range's subtype (i.e. if a range of integers, we'll serialize \"value\" as an integer).\n      return this._joinKeyValue(key, this.escape(value, {\n        ...field,\n        type: field.type.options.subtype,\n      }, escapeOptions), comparator, options.prefix);\n\n      // The case where \"value\" is a 'RANGE<VALUE>' is not a special case and is handled by the default case below.\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type,\n        replacements: options.replacements,\n      });\n    }\n\n    if (typeof smth === 'number' || typeof smth === 'bigint') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName,\n        replacements: options.replacements,\n      });\n    }\n\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        replacements: options.replacements,\n      });\n    }\n\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth, undefined, options);\n    }\n\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) {\n        return '1=1';\n      }\n\n      if (canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n\n    if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        replacements: options.replacements,\n      });\n    }\n\n    throw new Error(`Unsupported where option value: ${NodeUtil.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n\n      result.push({ path: path.concat(key), value });\n\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n}\n\nObject.assign(AbstractQueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(AbstractQueryGenerator.prototype, require('./query-generator/transaction'));\n"],
  "mappings": "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",
  "names": ["item", "NodeUtil", "opValue"]
}
