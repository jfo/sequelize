{
  "version": 3,
  "sources": ["../../../src/dialects/postgres/data-types.ts"],
  "sourcesContent": ["import assert from 'node:assert';\nimport wkx from 'wkx';\nimport type { Rangable } from '../../model.js';\nimport { isString } from '../../utils/check.js';\nimport type {\n  AcceptableTypeOf,\n  StringifyOptions,\n  BindParamOptions,\n  AcceptedDate,\n} from '../abstract/data-types';\nimport * as BaseTypes from '../abstract/data-types';\nimport type { AbstractDialect } from '../abstract/index.js';\nimport * as Hstore from './hstore';\nimport { PostgresQueryGenerator } from './query-generator';\nimport * as RangeParser from './range';\n\nfunction removeUnsupportedIntegerOptions(dataType: BaseTypes.BaseIntegerDataType, dialect: AbstractDialect) {\n  if (dataType.options.length != null) {\n    // this option only makes sense for zerofill\n    dialect.warnDataTypeIssue(`${dialect.name} does not support ${dataType.getDataTypeId()} with length specified. This options is ignored.`);\n\n    delete dataType.options.length;\n  }\n}\n\nexport class DATEONLY extends BaseTypes.DATEONLY {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.DATEONLY>, options: StringifyOptions) {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value, options);\n  }\n\n  sanitize(value: unknown): unknown {\n    if (value === Number.POSITIVE_INFINITY\n        || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n\n}\n\nexport class DECIMAL extends BaseTypes.DECIMAL {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class TEXT extends BaseTypes.TEXT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support TEXT with options. Plain TEXT will be used instead.`,\n      );\n\n      this.options.length = undefined;\n    }\n  }\n}\n\nexport class DATE extends BaseTypes.DATE {\n  toSql() {\n    if (this.options.precision != null) {\n      return `TIMESTAMP(${this.options.precision}) WITH TIME ZONE`;\n    }\n\n    return 'TIMESTAMP WITH TIME ZONE';\n  }\n\n  validate(value: any) {\n    if (value === Number.POSITIVE_INFINITY\n        || value === Number.NEGATIVE_INFINITY) {\n      // valid\n      return;\n    }\n\n    super.validate(value);\n  }\n\n  toBindableValue(\n    value: AcceptedDate,\n    options: StringifyOptions,\n  ): string {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value, options);\n  }\n\n  sanitize(value: unknown) {\n    if (value == null) {\n      return value;\n    }\n\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n}\n\nexport class TINYINT extends BaseTypes.TINYINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^8-1 check when the unsigned option is true\n  // TODO: add >= -2^7 =< 2^7-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'SMALLINT';\n  }\n}\n\nexport class SMALLINT extends BaseTypes.SMALLINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^16-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'INTEGER';\n    }\n\n    return 'SMALLINT';\n  }\n}\n\nexport class MEDIUMINT extends BaseTypes.MEDIUMINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^24-1 check when the unsigned option is true\n  // TODO: add >= -2^23 =< 2^23-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'INTEGER';\n  }\n}\n\nexport class INTEGER extends BaseTypes.INTEGER {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^32-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'BIGINT';\n    }\n\n    return 'INTEGER';\n  }\n}\n\nexport class BIGINT extends BaseTypes.BIGINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n}\n\nexport class DOUBLE extends BaseTypes.DOUBLE {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class FLOAT extends BaseTypes.FLOAT {\n  // TODO: add check constraint >= 0 if unsigned is true\n\n  protected getNumberSqlTypeName(): string {\n    // REAL is postgres' single precision float. FLOAT(p) is an alias for either REAL of DOUBLE PRECISION based on (p).\n    return 'REAL';\n  }\n}\n\nexport class BLOB extends BaseTypes.BLOB {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support BLOB (BYTEA) with options. Plain BYTEA will be used instead.`,\n      );\n      this.options.length = undefined;\n    }\n  }\n\n  toSql() {\n    return 'BYTEA';\n  }\n}\n\nexport class GEOMETRY extends BaseTypes.GEOMETRY {\n  toSql() {\n    let result = 'GEOMETRY';\n    if (this.options.type) {\n      result += `(${this.options.type.toUpperCase()}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  parse(value: string) {\n    const b = Buffer.from(value, 'hex');\n\n    return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n  }\n\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.GEOMETRY>, options: StringifyOptions): string {\n    return `ST_GeomFromGeoJSON(${options.dialect.escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOMETRY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n  toSql() {\n    let result = 'GEOGRAPHY';\n    if (this.options.type) {\n      result += `(${this.options.type}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  toBindableValue(\n    value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>,\n    options: StringifyOptions,\n  ) {\n    return `ST_GeomFromGeoJSON(${options.dialect.escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class HSTORE extends BaseTypes.HSTORE {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.HSTORE>): string {\n    if (value == null) {\n      return value;\n    }\n\n    return Hstore.stringify(value);\n  }\n}\n\nexport class RANGE<T extends BaseTypes.BaseNumberDataType | DATE | DATEONLY = INTEGER> extends BaseTypes.RANGE<T> {\n  toBindableValue(values: Rangable<AcceptableTypeOf<T>>, options: StringifyOptions) {\n    if (!Array.isArray(values)) {\n      return this.options.subtype.toBindableValue(values, options);\n    }\n\n    return RangeParser.stringify(values, rangePart => {\n      const out = this.options.subtype.toBindableValue(rangePart, options);\n\n      if (!isString(out)) {\n        throw new Error('DataTypes.RANGE only accepts types that can be stringified.');\n      }\n\n      return out;\n    });\n  }\n\n  escape(values: Rangable<AcceptableTypeOf<T>>, options: StringifyOptions): string {\n    const value = this.toBindableValue(values, options);\n    if (!Array.isArray(values)) {\n      return `'${value}'::${this.#toCastType()}`;\n    }\n\n    return `'${value}'`;\n  }\n\n  getBindParamSql(\n    values: Rangable<AcceptableTypeOf<T>>,\n    options: BindParamOptions,\n  ): string {\n    const value = this.toBindableValue(values, options);\n    if (!Array.isArray(values)) {\n      return `${options.bindParam(value ?? '')}::${this.#toCastType()}`;\n    }\n\n    return options.bindParam(value);\n  }\n\n  toSql() {\n    const subTypeClass = this.options.subtype.constructor as typeof BaseTypes.AbstractDataType;\n\n    return RANGE.typeMap.subTypes[subTypeClass.getDataTypeId().toLowerCase()];\n  }\n\n  #toCastType(): string {\n    const subTypeClass = this.options.subtype.constructor as typeof BaseTypes.AbstractDataType;\n\n    return RANGE.typeMap.castTypes[subTypeClass.getDataTypeId().toLowerCase()];\n  }\n\n  static typeMap: { subTypes: Record<string, string>, castTypes: Record<string, string> } = {\n    subTypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range',\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8',\n    },\n  };\n}\n\nexport class ARRAY<T extends BaseTypes.AbstractDataType<any>> extends BaseTypes.ARRAY<T> {\n  escape(\n    values: Array<AcceptableTypeOf<T>>,\n    options: StringifyOptions,\n  ) {\n    const type = this.options.type;\n\n    return `ARRAY[${values.map((value: any) => {\n      return type.escape(value, options);\n    }).join(',')}]::${type.toSql(options)}[]`;\n  }\n\n  getBindParamSql(\n    values: Array<AcceptableTypeOf<T>>,\n    options: BindParamOptions,\n  ) {\n    return options.bindParam(values.map((value: any) => {\n      return this.options.type.toBindableValue(value, options);\n    }));\n  }\n}\n\nexport class ENUM<Members extends string> extends BaseTypes.ENUM<Members> {\n  override toSql(): string {\n    const context = this.usageContext;\n    if (context == null) {\n      throw new Error('Could not determine the name of this enum because it is not attached to an attribute or a column.');\n    }\n\n    let tableName;\n    let columnName;\n    if ('model' in context) {\n      tableName = context.model.getTableName();\n\n      const attribute = context.model.getAttributes()[context.attributeName];\n      columnName = attribute.field ?? context.attributeName;\n    } else {\n      tableName = context.tableName;\n      columnName = context.columnName;\n    }\n\n    const queryGenerator = context.sequelize.dialect.queryGenerator;\n\n    assert(queryGenerator instanceof PostgresQueryGenerator, 'expected queryGenerator to be PostgresQueryGenerator');\n\n    return queryGenerator.pgEnumName(tableName, columnName);\n  }\n}\n"],
  "mappings": "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",
  "names": ["wkx", "assert"]
}
