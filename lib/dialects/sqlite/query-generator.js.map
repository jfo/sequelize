{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { addTicks, removeTicks } from '../../utils/dialect';\nimport { removeNullishValuesFromHash } from '../../utils/format';\nimport { defaultValueSchemable } from '../../utils/query-builder-utils';\nimport { rejectInvalidOptions } from '../../utils/check';\nimport { Cast, Json, SequelizeMethod } from '../../utils/sequelize-method';\nimport { underscore } from '../../utils/string';\nimport { ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS, REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS } from '../abstract/query-generator';\n\nconst { Transaction } = require('../../transaction');\nconst _ = require('lodash');\nconst { SqliteQueryGeneratorTypeScript } = require('./query-generator-typescript');\nconst { AbstractQueryGenerator } = require('../abstract/query-generator');\n\nconst ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\nconst REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\n\nexport class SqliteQueryGenerator extends SqliteQueryGeneratorTypeScript {\n  createSchemaQuery() {\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  dropSchemaQuery() {\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  listSchemasQuery() {\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.slice(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    // sqlite has a bug where using CONSTRAINT constraint_name UNIQUE during CREATE TABLE\n    //  does not respect the provided constraint name\n    //  and uses sqlite_autoindex_ as the name of the constraint instead.\n    //  CREATE UNIQUE INDEX does not have this issue, so we're using that instead\n    //\n    // if (options.uniqueKeys) {\n    //   _.each(options.uniqueKeys, (columns, indexName) => {\n    //     if (columns.customIndex) {\n    //       if (typeof indexName !== 'string') {\n    //         indexName = generateIndexName(tableName, columns);\n    //       }\n    //\n    //       attrStr += `, CONSTRAINT ${\n    //         this.quoteIdentifier(indexName)\n    //       } UNIQUE (${\n    //         columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n    //       })`;\n    //     }\n    //   });\n    // }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    if (options.limit != null) {\n      fragment += ` LIMIT ${this.escape(options.limit, undefined, options)}`;\n    } else if (options.offset) {\n      // limit must be specified if offset is specified.\n      fragment += ` LIMIT -1`;\n    }\n\n    if (options.offset) {\n      fragment += ` OFFSET ${this.escape(options.offset, undefined, options)}`;\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([\"'`])(?:(?!\\2).|\\2{2})*\\2)|[\\s\\w]+|[()+,.;-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.slice(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  // sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Cast && /timestamp/i.test(smth.type)) {\n      smth.type = 'datetime';\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'addColumnQuery',\n        this.dialect.name,\n        ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = removeNullishValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = Object.create(null);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE', replacements: options.replacements })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE', replacements: options.replacements }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit, undefined, options)})`.trim();\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`.trim();\n    }\n\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${addTicks(removeTicks(this.quoteTable(tableName), '`'), '\\'')};` : '',\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit, undefined, options)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`.trim();\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const columnName = attribute.field || attribute.columnName || name;\n\n      if (_.isObject(attribute)) {\n        let sql = attribute.type.toString();\n\n        if (attribute.allowNull === false) {\n          sql += ' NOT NULL';\n        }\n\n        if (defaultValueSchemable(attribute.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute, options)}`;\n        }\n\n        if (attribute.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (attribute.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (attribute.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (attribute.references) {\n          const referencesTable = this.quoteTable(attribute.references.table);\n\n          let referencesKey;\n          if (attribute.references.key) {\n            referencesKey = this.quoteIdentifier(attribute.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (attribute.onDelete) {\n            sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n          }\n\n          if (attribute.onUpdate) {\n            sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n          }\n        }\n\n        result[columnName] = sql;\n      } else {\n        result[columnName] = attribute;\n      }\n    }\n\n    return result;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'removeColumnQuery',\n        this.dialect.name,\n        REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema,\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${this.createTableQuery(backupTableName, attributes)}`\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema,\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema,\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => (attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr))).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {TableName} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(tableName)})`;\n  }\n\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.extractTableDetails(tableName).tableName)};`;\n  }\n\n  /**\n   * Generates an SQL query to check if there are any foreign key violations in the db schema\n   *\n   * @param {string} tableName  The name of the table\n   */\n  foreignKeyCheckQuery(tableName) {\n    return `PRAGMA foreign_key_check(${this.quoteTable(tableName)});`;\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column  The JSON column\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\n   * @returns {string}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    const pathStr = this.escape(['$']\n      .concat(_.toPath(path))\n      .join('.')\n      .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n    return `json_extract(${quotedColumn},${pathStr})`;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
