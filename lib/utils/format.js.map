{
  "version": 3,
  "sources": ["../../src/utils/format.ts"],
  "sourcesContent": ["import assert from 'node:assert';\nimport forIn from 'lodash/forIn';\nimport isPlainObject from 'lodash/isPlainObject';\nimport type {\n  Attributes,\n  NormalizedAttributeOptions,\n  Model,\n  ModelStatic,\n  WhereOptions,\n} from '..';\nimport * as DataTypes from '../data-types';\nimport { Op as operators } from '../operators';\nimport { isString } from './check.js';\n\nconst operatorsSet = new Set(Object.values(operators));\n\nexport type FinderOptions<TAttributes> = {\n  attributes?: string[],\n  where?: WhereOptions<TAttributes>,\n};\n\nexport type MappedFinderOptions<TAttributes> = Omit<FinderOptions<TAttributes>, 'attributes'> & {\n  // an array of attribute-column mapping, or just attributes\n  attributes?: Array<[columnName: string, attributeName: string] | string>,\n};\n\n/**\n * Expand and normalize finder options.\n * Mutates the \"options\" parameter.\n *\n * @param options\n * @param Model\n */\nexport function mapFinderOptions<M extends Model, T extends FinderOptions<Attributes<M>>>(\n  options: T,\n  Model: ModelStatic<M>,\n): MappedFinderOptions<Attributes<M>> {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(\n      options.attributes,\n    );\n\n    const modelDefinition = Model.modelDefinition;\n    options.attributes = options.attributes.filter(\n      attributeName => !modelDefinition.virtualAttributeNames.has(attributeName),\n    );\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\n\n/**\n * Used to map field names in attributes and where conditions.\n *\n * Mutates the \"options\" parameter.\n *\n * @param options\n * @param Model\n */\nexport function mapOptionFieldNames<M extends Model>(\n  options: FinderOptions<Attributes<M>>,\n  Model: ModelStatic,\n): MappedFinderOptions<Attributes<M>> {\n\n  // note: parts of Sequelize rely on this function mutating its inputs.\n  //  be aware that these places need to be fixed before trying to make this a pure function.\n  //  - ephys\n\n  const out: MappedFinderOptions<Attributes<M>> = options;\n\n  if (Array.isArray(options.attributes)) {\n    out.attributes = options.attributes.map(attributeName => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attributeName !== 'string') {\n        return attributeName;\n      }\n\n      // Map attributes to column names\n      const columnName: string = Model.modelDefinition.getColumnNameLoose(attributeName);\n      if (columnName !== attributeName) {\n        return [columnName, attributeName];\n      }\n\n      return attributeName;\n    });\n  }\n\n  if (options.where != null && isPlainObject(options.where)) {\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error -- this fails in TS 4.4 and up, but not before\n    // @ts-ignore the work necessary to type the return type of mapWhereFieldNames is not worth it\n    out.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return out;\n}\n\nexport function mapWhereFieldNames(where: Record<PropertyKey, any>, Model: ModelStatic<Model>): object {\n  if (!where) {\n    return where;\n  }\n\n  const modelDefinition = Model.modelDefinition;\n\n  const newWhere: Record<PropertyKey, any> = Object.create(null);\n  for (const attributeNameOrOperator of getComplexKeys(where)) {\n    const rawAttribute: NormalizedAttributeOptions | undefined = isString(attributeNameOrOperator)\n      ? modelDefinition.attributes.get(attributeNameOrOperator)\n      : undefined;\n\n    const columnNameOrOperator: PropertyKey = rawAttribute?.field ?? attributeNameOrOperator;\n\n    if (\n      isPlainObject(where[attributeNameOrOperator])\n        && !(\n          rawAttribute\n          && (rawAttribute.type instanceof DataTypes.HSTORE\n            || rawAttribute.type instanceof DataTypes.JSON)\n        )\n    ) {\n      // Prevent renaming of HSTORE & JSON fields\n      newWhere[columnNameOrOperator] = mapOptionFieldNames(\n        {\n          where: where[attributeNameOrOperator],\n        },\n        Model,\n      ).where;\n\n      continue;\n    }\n\n    if (Array.isArray(where[attributeNameOrOperator])) {\n      newWhere[columnNameOrOperator] = [...where[attributeNameOrOperator]];\n\n      for (const [index, wherePart] of where[attributeNameOrOperator].entries()) {\n        if (isPlainObject(wherePart)) {\n          newWhere[columnNameOrOperator][index] = mapWhereFieldNames(wherePart, Model);\n        }\n      }\n\n      continue;\n    }\n\n    newWhere[columnNameOrOperator] = where[attributeNameOrOperator];\n  }\n\n  return newWhere;\n}\n\n/**\n * getComplexKeys\n *\n * @param obj\n * @returns All keys including operators\n * @private\n */\nexport function getComplexKeys(obj: object): Array<string | symbol> {\n  return [\n    ...getOperators(obj),\n    ...Object.keys(obj),\n  ];\n}\n\n/**\n * getComplexSize\n *\n * @param obj\n * @returns Length of object properties including operators if obj is array returns its length\n * @private\n */\nexport function getComplexSize(obj: object | any[]): number {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\n\n/**\n * getOperators\n *\n * @param obj\n * @returns All operators properties of obj\n * @private\n */\nexport function getOperators(obj: object): symbol[] {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\n\nexport function combineTableNames(tableName1: string, tableName2: string): string {\n  return tableName1.toLowerCase() < tableName2.toLowerCase()\n    ? tableName1 + tableName2\n    : tableName2 + tableName1;\n}\n\n/**\n * Used to map field names in values\n *\n * @param dataValues\n * @param attributeNames\n * @param ModelClass\n */\nexport function mapValueFieldNames( // TODO: rename to mapAttributesToColumNames? See https://github.com/sequelize/meetings/issues/17\n  dataValues: Record<string, any>,\n  attributeNames: Iterable<string>,\n  ModelClass: ModelStatic,\n): Record<string, any> {\n  const values: Record<string, any> = Object.create(null);\n  const modelDefinition = ModelClass.modelDefinition;\n\n  for (const attributeName of attributeNames) {\n    if (dataValues[attributeName] !== undefined && !modelDefinition.virtualAttributeNames.has(attributeName)) {\n      // Field name mapping\n      const columnName = modelDefinition.getColumnNameLoose(attributeName);\n\n      values[columnName] = dataValues[attributeName];\n    }\n  }\n\n  return values;\n}\n\n/**\n * Removes entries from `hash` whose value is either null or undefined, unless `omitNull` is false or `allowNull` includes that key.\n *\n * Keys ending with 'Id' are never removed.\n *\n * @param hash the object from which entries with nullish values will be removed.\n * @param omitNull if false, this method returns the object as-is\n * @param options\n * @param options.allowNull A list of keys that must be preserved even if their value is null or undefined.\n */\nexport function removeNullishValuesFromHash(\n  hash: Record<string, any>,\n  omitNull: boolean,\n  options?: { allowNull?: string[] },\n): Record<string, any> {\n  let result = hash;\n\n  const allowNull = options?.allowNull ?? [];\n\n  if (!omitNull) {\n    return result;\n  }\n\n  const _hash: { [key: string]: any } = Object.create(null);\n\n  forIn(hash, (val: any, key: string) => {\n    if (\n      allowNull.includes(key)\n        || key.endsWith('Id')\n        || val !== null && val !== undefined\n    ) {\n      _hash[key] = val;\n    }\n  });\n\n  result = _hash;\n\n  return result;\n}\n\nexport function getColumnName(attribute: NormalizedAttributeOptions): string {\n  assert(attribute.fieldName != null, 'getColumnName expects a normalized attribute meta');\n\n  // field is the column name alias\n  // if no alias is set, fieldName (the JS name) will be used instead.\n  return attribute.field || attribute.fieldName;\n}\n\nexport function getAttributeName(model: ModelStatic, columnName: string): string | null {\n  return Object.values(model.getAttributes()).find(attribute => attribute.field === columnName)?.fieldName ?? null;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAAmB;AACnB,mBAAkB;AAClB,2BAA0B;AAQ1B,gBAA2B;AAC3B,uBAAgC;AAChC,mBAAyB;AAEzB,MAAM,eAAe,IAAI,IAAI,OAAO,OAAO,iBAAAA,EAAS,CAAC;AAmB9C,SAAS,iBACd,SACA,OACoC;AACpC,MAAI,MAAM,QAAQ,QAAQ,UAAU,GAAG;AACrC,YAAQ,aAAa,MAAM;AAAA,MACzB,QAAQ;AAAA,IACV;AAEA,UAAM,kBAAkB,MAAM;AAC9B,YAAQ,aAAa,QAAQ,WAAW;AAAA,MACtC,mBAAiB,CAAC,gBAAgB,sBAAsB,IAAI,aAAa;AAAA,IAC3E;AAAA,EACF;AAEA,sBAAoB,SAAS,KAAK;AAElC,SAAO;AACT;AAUO,SAAS,oBACd,SACA,OACoC;AAMpC,QAAM,MAA0C;AAEhD,MAAI,MAAM,QAAQ,QAAQ,UAAU,GAAG;AACrC,QAAI,aAAa,QAAQ,WAAW,IAAI,mBAAiB;AAEvD,UAAI,OAAO,kBAAkB,UAAU;AACrC,eAAO;AAAA,MACT;AAGA,YAAM,aAAqB,MAAM,gBAAgB,mBAAmB,aAAa;AACjF,UAAI,eAAe,eAAe;AAChC,eAAO,CAAC,YAAY,aAAa;AAAA,MACnC;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,MAAI,QAAQ,SAAS,YAAQ,qBAAAC,SAAc,QAAQ,KAAK,GAAG;AAGzD,QAAI,QAAQ,mBAAmB,QAAQ,OAAO,KAAK;AAAA,EACrD;AAEA,SAAO;AACT;AAEO,SAAS,mBAAmB,OAAiC,OAAmC;AACrG,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB,MAAM;AAE9B,QAAM,WAAqC,uBAAO,OAAO,IAAI;AAC7D,aAAW,2BAA2B,eAAe,KAAK,GAAG;AAC3D,UAAM,mBAAuD,uBAAS,uBAAuB,IACzF,gBAAgB,WAAW,IAAI,uBAAuB,IACtD;AAEJ,UAAM,wBAAoC,6CAAc,UAAS;AAEjE,YACE,qBAAAA,SAAc,MAAM,uBAAuB,CAAC,KACvC,EACD,iBACI,aAAa,gBAAgB,UAAU,UACtC,aAAa,gBAAgB,UAAU,QAEhD;AAEA,eAAS,oBAAoB,IAAI;AAAA,QAC/B;AAAA,UACE,OAAO,MAAM,uBAAuB;AAAA,QACtC;AAAA,QACA;AAAA,MACF,EAAE;AAEF;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,MAAM,uBAAuB,CAAC,GAAG;AACjD,eAAS,oBAAoB,IAAI,CAAC,GAAG,MAAM,uBAAuB,CAAC;AAEnE,iBAAW,CAAC,OAAO,SAAS,KAAK,MAAM,uBAAuB,EAAE,QAAQ,GAAG;AACzE,gBAAI,qBAAAA,SAAc,SAAS,GAAG;AAC5B,mBAAS,oBAAoB,EAAE,KAAK,IAAI,mBAAmB,WAAW,KAAK;AAAA,QAC7E;AAAA,MACF;AAEA;AAAA,IACF;AAEA,aAAS,oBAAoB,IAAI,MAAM,uBAAuB;AAAA,EAChE;AAEA,SAAO;AACT;AASO,SAAS,eAAe,KAAqC;AAClE,SAAO;AAAA,IACL,GAAG,aAAa,GAAG;AAAA,IACnB,GAAG,OAAO,KAAK,GAAG;AAAA,EACpB;AACF;AASO,SAAS,eAAe,KAA6B;AAC1D,SAAO,MAAM,QAAQ,GAAG,IAAI,IAAI,SAAS,eAAe,GAAG,EAAE;AAC/D;AASO,SAAS,aAAa,KAAuB;AAClD,SAAO,OAAO,sBAAsB,GAAG,EAAE,OAAO,OAAK,aAAa,IAAI,CAAC,CAAC;AAC1E;AAEO,SAAS,kBAAkB,YAAoB,YAA4B;AAChF,SAAO,WAAW,YAAY,IAAI,WAAW,YAAY,IACrD,aAAa,aACb,aAAa;AACnB;AASO,SAAS,mBACd,YACA,gBACA,YACqB;AACrB,QAAM,SAA8B,uBAAO,OAAO,IAAI;AACtD,QAAM,kBAAkB,WAAW;AAEnC,aAAW,iBAAiB,gBAAgB;AAC1C,QAAI,WAAW,aAAa,MAAM,UAAa,CAAC,gBAAgB,sBAAsB,IAAI,aAAa,GAAG;AAExG,YAAM,aAAa,gBAAgB,mBAAmB,aAAa;AAEnE,aAAO,UAAU,IAAI,WAAW,aAAa;AAAA,IAC/C;AAAA,EACF;AAEA,SAAO;AACT;AAYO,SAAS,4BACd,MACA,UACA,SACqB;AACrB,MAAI,SAAS;AAEb,QAAM,aAAY,mCAAS,cAAa,CAAC;AAEzC,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAEA,QAAM,QAAgC,uBAAO,OAAO,IAAI;AAExD,mBAAAC,SAAM,MAAM,CAAC,KAAU,QAAgB;AACrC,QACE,UAAU,SAAS,GAAG,KACjB,IAAI,SAAS,IAAI,KACjB,QAAQ,QAAQ,QAAQ,QAC7B;AACA,YAAM,GAAG,IAAI;AAAA,IACf;AAAA,EACF,CAAC;AAED,WAAS;AAET,SAAO;AACT;AAEO,SAAS,cAAc,WAA+C;AAC3E,yBAAAC,SAAO,UAAU,aAAa,MAAM,mDAAmD;AAIvF,SAAO,UAAU,SAAS,UAAU;AACtC;AAEO,SAAS,iBAAiB,OAAoB,YAAmC;AA3QxF;AA4QE,WAAO,YAAO,OAAO,MAAM,cAAc,CAAC,EAAE,KAAK,eAAa,UAAU,UAAU,UAAU,MAArF,mBAAwF,cAAa;AAC9G;",
  "names": ["operators", "isPlainObject", "forIn", "assert"]
}
