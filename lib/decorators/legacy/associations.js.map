{
  "version": 3,
  "sources": ["../../../src/decorators/legacy/associations.ts"],
  "sourcesContent": ["import type { MaybeForwardedModelStatic } from '../../associations/helpers.js';\nimport { AssociationSecret, getForwardedModel } from '../../associations/helpers.js';\nimport type {\n  AssociationOptions,\n  BelongsToManyOptions,\n  BelongsToOptions,\n  HasManyOptions,\n  HasOneOptions,\n} from '../../associations/index.js';\nimport { BelongsTo as BelongsToAssociation, HasMany as HasManyAssociation, HasOne as HasOneAssociation, BelongsToMany as BelongsToManyAssociation } from '../../associations/index.js';\nimport type { ModelStatic, Model, AttributeNames } from '../../model.js';\nimport type { Sequelize } from '../../sequelize.js';\nimport { isString } from '../../utils/check.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport { throwMustBeInstanceProperty, throwMustBeModel } from './decorator-utils.js';\n\nexport type AssociationType = 'BelongsTo' | 'HasOne' | 'HasMany' | 'BelongsToMany';\n\ninterface RegisteredAssociation {\n  type: AssociationType;\n  associationName: string;\n  source: ModelStatic;\n  target: MaybeForwardedModelStatic;\n  options: AssociationOptions;\n}\n\nconst registeredAssociations = new WeakMap<ModelStatic, RegisteredAssociation[]>();\n\nfunction decorateAssociation(\n  type: AssociationType,\n  source: Object,\n  target: MaybeForwardedModelStatic,\n  associationName: string | symbol,\n  options: AssociationOptions,\n): void {\n  if (typeof source === 'function') {\n    throwMustBeInstanceProperty(type, source, associationName);\n  }\n\n  const sourceClass = source.constructor;\n  if (!isModelStatic(sourceClass)) {\n    throwMustBeModel(type, source, associationName);\n  }\n\n  if (typeof associationName === 'symbol') {\n    throw new TypeError('Symbol associations are not currently supported. We welcome a PR that implements this feature.');\n  }\n\n  const associations = registeredAssociations.get(sourceClass) ?? [];\n  registeredAssociations.set(sourceClass, associations);\n\n  associations.push({ source: sourceClass, target, options, associationName, type });\n}\n\nexport function HasOne<Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey: HasOneOptions<string, AttributeNames<Target>> | AttributeNames<Target>,\n) {\n  return (source: Model, associationName: string | symbol) => {\n    const options = isString(optionsOrForeignKey) ? { foreignKey: optionsOrForeignKey } : optionsOrForeignKey;\n\n    decorateAssociation('HasOne', source, target, associationName, options);\n  };\n}\n\nexport function HasMany<Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey: HasManyOptions<string, AttributeNames<Target>> | AttributeNames<Target>,\n) {\n  return (source: Model, associationName: string | symbol) => {\n    const options = isString(optionsOrForeignKey) ? { foreignKey: optionsOrForeignKey } : optionsOrForeignKey;\n\n    decorateAssociation('HasMany', source, target, associationName, options);\n  };\n}\n\nexport function BelongsTo<SourceKey extends string, Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey: BelongsToOptions<SourceKey, AttributeNames<Target>> | SourceKey,\n) {\n  return (\n    // This type is a hack to make sure the source model declares a property named [SourceKey].\n    // The error message is going to be horrendous, but at least it's enforced.\n    source: Model<{ [key in SourceKey]: unknown }>,\n    associationName: string,\n  ) => {\n    const options = isString(optionsOrForeignKey) ? { foreignKey: optionsOrForeignKey } : optionsOrForeignKey;\n\n    decorateAssociation('BelongsTo', source, target, associationName, options);\n  };\n}\n\nexport function BelongsToMany(\n  target: MaybeForwardedModelStatic,\n  options: BelongsToManyOptions,\n): PropertyDecorator {\n  return (\n    source: Object,\n    associationName: string | symbol,\n  ) => {\n    decorateAssociation('BelongsToMany', source, target, associationName, options);\n  };\n}\n\nexport function initDecoratedAssociations(model: ModelStatic, sequelize: Sequelize): void {\n  const associations = registeredAssociations.get(model);\n\n  if (!associations) {\n    return;\n  }\n\n  for (const association of associations) {\n    const { type, source, target: targetGetter, associationName } = association;\n    const options: AssociationOptions = { ...association.options, as: associationName };\n\n    const target = getForwardedModel(targetGetter, sequelize);\n\n    switch (type) {\n      case 'BelongsTo':\n        BelongsToAssociation.associate(AssociationSecret, source, target, options as BelongsToOptions<string, string>);\n        break;\n      case 'HasOne':\n        HasOneAssociation.associate(AssociationSecret, source, target, options as HasOneOptions<string, string>);\n        break;\n      case 'HasMany':\n        HasManyAssociation.associate(AssociationSecret, source, target, options as HasManyOptions<string, string>);\n        break;\n      case 'BelongsToMany':\n        BelongsToManyAssociation.associate(AssociationSecret, source, target, options as BelongsToManyOptions);\n        break;\n      default:\n        throw new Error(`Unknown association type: ${type}`);\n    }\n  }\n}\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,qBAAqD;AAQrD,0BAAyJ;AAGzJ,mBAAyB;AACzB,yBAA8B;AAC9B,6BAA8D;AAY9D,MAAM,yBAAyB,oBAAI,QAA8C;AAEjF,SAAS,oBACP,MACA,QACA,QACA,iBACA,SACM;AACN,MAAI,OAAO,WAAW,YAAY;AAChC,4DAA4B,MAAM,QAAQ,eAAe;AAAA,EAC3D;AAEA,QAAM,cAAc,OAAO;AAC3B,MAAI,KAAC,kCAAc,WAAW,GAAG;AAC/B,iDAAiB,MAAM,QAAQ,eAAe;AAAA,EAChD;AAEA,MAAI,OAAO,oBAAoB,UAAU;AACvC,UAAM,IAAI,UAAU,gGAAgG;AAAA,EACtH;AAEA,QAAM,eAAe,uBAAuB,IAAI,WAAW,KAAK,CAAC;AACjE,yBAAuB,IAAI,aAAa,YAAY;AAEpD,eAAa,KAAK,EAAE,QAAQ,aAAa,QAAQ,SAAS,iBAAiB,KAAK,CAAC;AACnF;AAEO,SAAS,OACd,QACA,qBACA;AACA,SAAO,CAAC,QAAe,oBAAqC;AAC1D,UAAM,cAAU,uBAAS,mBAAmB,IAAI,EAAE,YAAY,oBAAoB,IAAI;AAEtF,wBAAoB,UAAU,QAAQ,QAAQ,iBAAiB,OAAO;AAAA,EACxE;AACF;AAEO,SAAS,QACd,QACA,qBACA;AACA,SAAO,CAAC,QAAe,oBAAqC;AAC1D,UAAM,cAAU,uBAAS,mBAAmB,IAAI,EAAE,YAAY,oBAAoB,IAAI;AAEtF,wBAAoB,WAAW,QAAQ,QAAQ,iBAAiB,OAAO;AAAA,EACzE;AACF;AAEO,SAAS,UACd,QACA,qBACA;AACA,SAAO,CAGL,QACA,oBACG;AACH,UAAM,cAAU,uBAAS,mBAAmB,IAAI,EAAE,YAAY,oBAAoB,IAAI;AAEtF,wBAAoB,aAAa,QAAQ,QAAQ,iBAAiB,OAAO;AAAA,EAC3E;AACF;AAEO,SAAS,cACd,QACA,SACmB;AACnB,SAAO,CACL,QACA,oBACG;AACH,wBAAoB,iBAAiB,QAAQ,QAAQ,iBAAiB,OAAO;AAAA,EAC/E;AACF;AAEO,SAAS,0BAA0B,OAAoB,WAA4B;AACxF,QAAM,eAAe,uBAAuB,IAAI,KAAK;AAErD,MAAI,CAAC,cAAc;AACjB;AAAA,EACF;AAEA,aAAW,eAAe,cAAc;AACtC,UAAM,EAAE,MAAM,QAAQ,QAAQ,cAAc,gBAAgB,IAAI;AAChE,UAAM,UAA8B,EAAE,GAAG,YAAY,SAAS,IAAI,gBAAgB;AAElF,UAAM,aAAS,kCAAkB,cAAc,SAAS;AAExD,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,4BAAAA,UAAqB,UAAU,kCAAmB,QAAQ,QAAQ,OAA2C;AAC7G;AAAA,MACF,KAAK;AACH,4BAAAC,OAAkB,UAAU,kCAAmB,QAAQ,QAAQ,OAAwC;AACvG;AAAA,MACF,KAAK;AACH,4BAAAC,QAAmB,UAAU,kCAAmB,QAAQ,QAAQ,OAAyC;AACzG;AAAA,MACF,KAAK;AACH,4BAAAC,cAAyB,UAAU,kCAAmB,QAAQ,QAAQ,OAA+B;AACrG;AAAA,MACF;AACE,cAAM,IAAI,MAAM,6BAA6B,MAAM;AAAA,IACvD;AAAA,EACF;AACF;",
  "names": ["BelongsToAssociation", "HasOneAssociation", "HasManyAssociation", "BelongsToManyAssociation"]
}
