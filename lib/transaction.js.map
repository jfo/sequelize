{
  "version": 3,
  "sources": ["../src/transaction.ts"],
  "sourcesContent": ["import assert from 'node:assert';\nimport type { Class } from 'type-fest';\nimport type { RequiredBy } from './utils/types.js';\nimport type { Logging, Deferrable, Connection, Sequelize } from './index.js';\n\ntype AfterTransactionCommitCallback = (transaction: Transaction) => void | Promise<void>;\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {Sequelize.transaction}\n */\nexport class Transaction {\n\n  sequelize: Sequelize;\n\n  private readonly _afterCommitHooks: Set<AfterTransactionCommitCallback> = new Set();\n  private readonly savepoints: Transaction[] = [];\n  private readonly options: RequiredBy<TransactionOptions, 'type' | 'isolationLevel' | 'readOnly'>;\n  private readonly parent: Transaction | null;\n  readonly id: string;\n  private readonly name: string;\n  private finished: 'commit' | undefined;\n  private connection: Connection | undefined;\n\n  /**\n   * Creates a new transaction instance\n   *\n   * @param sequelize A configured sequelize Instance\n   * @param options An object with options\n   * @param [options.type] Sets the type of the transaction. Sqlite only\n   * @param [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize: Sequelize, options: TransactionOptions) {\n    this.sequelize = sequelize;\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect\n      .queryGenerator\n      .generateTransactionId;\n\n    this.options = {\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false,\n      ...options,\n    };\n\n    this.parent = this.options.transaction ?? null;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      const id = generateTransactionId();\n      this.id = id;\n      this.name = id;\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction.\n   */\n  async commit(): Promise<void> {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      for (const hook of this._afterCommitHooks) {\n        // eslint-disable-next-line no-await-in-loop -- sequentially call hooks\n        await Reflect.apply(hook, this, [this]);\n      }\n\n      this.cleanup();\n    } catch (error) {\n      console.warn(`Committing transaction ${this.id} failed with error ${error instanceof Error ? JSON.stringify(error.message) : String(error)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n\n      throw error;\n    } finally {\n      this.finished = 'commit';\n    }\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   */\n  async rollback(): Promise<void> {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n\n    if (!this.connection) {\n      throw new Error('Transaction cannot be rolled back because it never started');\n    }\n\n    try {\n      await this\n        .sequelize\n        .getQueryInterface()\n        .rollbackTransaction(this, this.options);\n\n      this.cleanup();\n    } catch (error) {\n      console.warn(`Rolling back transaction ${this.id} failed with error ${error instanceof Error ? JSON.stringify(error.message) : String(error)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n\n      throw error;\n    }\n  }\n\n  /**\n   * Called to acquire a connection to use and set the correct options on the connection.\n   * We should ensure all the environment that's set up is cleaned up in `cleanup()` below.\n   */\n  async prepareEnvironment() {\n    let connection;\n    if (this.parent) {\n      connection = this.parent.connection;\n    } else {\n      connection = await this.sequelize.connectionManager.getConnection({\n        type: this.options.readOnly ? 'read' : 'write',\n        uuid: this.id,\n      });\n    }\n\n    assert(connection != null, 'Transaction failed to acquire Connection.');\n\n    connection.uuid = this.id;\n\n    this.connection = connection;\n\n    let result;\n    try {\n      await this.begin();\n\n      result = await this.setDeferrable();\n    } catch (error) {\n      try {\n        await this.rollback();\n      } finally {\n        throw error; // eslint-disable-line no-unsafe-finally -- while this will mask the error thrown by `rollback`, the previous error is more important.\n      }\n    }\n\n    return result;\n  }\n\n  async setDeferrable(): Promise<void> {\n    if (this.options.deferrable) {\n      await this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n\n    return queryInterface.startTransaction(this, this.options);\n  }\n\n  cleanup(): void {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection?.uuid === undefined) {\n      return;\n    }\n\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n  }\n\n  /**\n   * Kills the connection this transaction uses.\n   * Used as a last resort, for instance because COMMIT or ROLLBACK resulted in an error\n   * and the transaction is left in a broken state,\n   * and releasing the connection to the pool would be dangerous.\n   */\n  async forceCleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection?.uuid === undefined) {\n      return;\n    }\n\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = undefined;\n  }\n\n  /**\n   * Adds a hook that is run after a transaction is committed.\n   *\n   * @param fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn: AfterTransactionCommitCallback): this {\n    if (typeof fn !== 'function') {\n      throw new TypeError('\"fn\" must be a function');\n    }\n\n    this._afterCommitHooks.add(fn);\n\n    return this;\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\n   *      // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return TRANSACTION_TYPES;\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *     // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return ISOLATION_LEVELS;\n  }\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example Postgres also supports specific locks while eager loading by using OF:\n   * ```ts\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   * ```\n   *\n   * UserModel will be locked but TaskModel won't!\n   *\n   * @example You can also skip locked rows:\n   * ```ts\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * ```\n   *\n   * The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns possible options for row locking\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return LOCK;\n  }\n\n  /**\n   * Same as {@link Transaction.LOCK}, but can also be called on instances of\n   * transactions to get possible options for row locking directly from the\n   * instance.\n   */\n  get LOCK() {\n    return LOCK;\n  }\n}\n\n/**\n * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\n *\n * The possible isolations levels to use when starting a transaction:\n *\n * ```js\n * {\n *   READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n *   READ_COMMITTED: \"READ COMMITTED\",\n *   REPEATABLE_READ: \"REPEATABLE READ\",\n *   SERIALIZABLE: \"SERIALIZABLE\"\n * }\n * ```\n *\n * Pass in the desired level as the first argument:\n *\n * ```js\n * try {\n *   await sequelize.transaction({isolationLevel: Sequelize.Transaction.SERIALIZABLE}, transaction => {\n *      // your transactions\n *   });\n *   // transaction has been committed. Do something after the commit if required.\n * } catch(err) {\n *   // do something with the err.\n * }\n * ```\n */\n// TODO [>=8]: Rename to IsolationLevel\nexport enum ISOLATION_LEVELS {\n  READ_UNCOMMITTED = 'READ UNCOMMITTED',\n  READ_COMMITTED = 'READ COMMITTED',\n  REPEATABLE_READ = 'REPEATABLE READ',\n  SERIALIZABLE = 'SERIALIZABLE',\n}\n\n// TODO [>=8]: Rename to TransactionType\nexport enum TRANSACTION_TYPES {\n  DEFERRED = 'DEFERRED',\n  IMMEDIATE = 'IMMEDIATE',\n  EXCLUSIVE = 'EXCLUSIVE',\n}\n\n/**\n * Possible options for row locking. Used in conjunction with `find` calls:\n *\n * Usage:\n * ```js\n * import { LOCK } from '@sequelize/core';\n *\n * Model.findAll({\n *   transaction,\n *   lock: LOCK.UPDATE,\n * });\n * ```\n *\n * Postgres also supports specific locks while eager loading by using OF:\n * ```js\n * import { LOCK } from '@sequelize/core';\n *\n * UserModel.findAll({\n *   transaction,\n *   lock: {\n *     level: LOCK.KEY_SHARE,\n *     of: UserModel,\n *   },\n * });\n * ```\n * UserModel will be locked but other models won't be!\n *\n * [Read more on transaction locks here](https://sequelize.org/docs/v7/other-topics/transactions/#locks)\n */\n// TODO [>=8]: Rename to Lock\nexport enum LOCK {\n  UPDATE = 'UPDATE',\n  SHARE = 'SHARE',\n  /**\n   * Postgres 9.3+ only\n   */\n  KEY_SHARE = 'KEY SHARE',\n  /**\n   * Postgres 9.3+ only\n   */\n  NO_KEY_UPDATE = 'NO KEY UPDATE',\n}\n\n/**\n * Options provided when the transaction is created\n */\nexport interface TransactionOptions extends Logging {\n  readOnly?: boolean;\n  autocommit?: boolean;\n  isolationLevel?: ISOLATION_LEVELS;\n  type?: TRANSACTION_TYPES;\n  deferrable?: string | Deferrable | Class<Deferrable>;\n  /**\n   * Parent transaction.\n   */\n  transaction?: Transaction | null;\n}\n"],
  "mappings": "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",
  "names": ["assert", "ISOLATION_LEVELS", "TRANSACTION_TYPES", "LOCK"]
}
