{
  "version": 3,
  "sources": ["../src/sql-string.ts"],
  "sourcesContent": ["import * as DataTypes from './data-types';\nimport type { AbstractDataType } from './dialects/abstract/data-types.js';\nimport type { AbstractDialect } from './dialects/abstract/index.js';\nimport { logger } from './utils/logger';\n\nfunction arrayToList(array: unknown[], timeZone: string | undefined, dialect: AbstractDialect, format: boolean) {\n  // TODO: rewrite\n  // eslint-disable-next-line unicorn/no-array-reduce\n  return array.reduce((sql: string, val, i) => {\n    if (i !== 0) {\n      sql += ', ';\n    }\n\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format);\n    }\n\n    return sql;\n  }, '');\n}\n\nconst textDataTypeMap = new Map<string, AbstractDataType<any>>();\nexport function getTextDataTypeForDialect(dialect: AbstractDialect): AbstractDataType<any> {\n  let type = textDataTypeMap.get(dialect.name);\n  if (type == null) {\n    type = new DataTypes.STRING().toDialectDataType(dialect);\n    textDataTypeMap.set(dialect.name, type);\n  }\n\n  return type;\n}\n\nfunction bestGuessDataTypeOfVal(val: unknown, dialect: AbstractDialect): AbstractDataType<any> {\n  // TODO: cache simple types\n  switch (typeof val) {\n    case 'bigint':\n      return new DataTypes.BIGINT().toDialectDataType(dialect);\n\n    case 'number': {\n      if (Number.isSafeInteger(val)) {\n        return new DataTypes.INTEGER().toDialectDataType(dialect);\n      }\n\n      return new DataTypes.REAL().toDialectDataType(dialect);\n    }\n\n    case 'boolean':\n      return new DataTypes.BOOLEAN().toDialectDataType(dialect);\n\n    case 'object':\n      if (Array.isArray(val)) {\n        if (val.length === 0) {\n          throw new Error(`Could not guess type of value ${logger.inspect(val)} because it is an empty array`);\n        }\n\n        return new DataTypes.ARRAY(bestGuessDataTypeOfVal(val[0], dialect)).toDialectDataType(dialect);\n      }\n\n      if (val instanceof Date) {\n        return new DataTypes.DATE().toDialectDataType(dialect);\n      }\n\n      if (Buffer.isBuffer(val)) {\n        // TODO: remove dialect-specific hack\n        if (dialect.name === 'ibmi') {\n          return new DataTypes.STRING().toDialectDataType(dialect);\n        }\n\n        return new DataTypes.BLOB().toDialectDataType(dialect);\n      }\n\n      break;\n\n    case 'string':\n      return getTextDataTypeForDialect(dialect);\n\n    default:\n  }\n\n  throw new TypeError(`Could not guess type of value ${logger.inspect(val)}`);\n}\n\nexport function escape(\n  val: unknown,\n  timeZone: string | undefined,\n  dialect: AbstractDialect,\n  format: boolean = false,\n): string {\n  const dialectName = dialect.name;\n\n  if (val == null) {\n    // There are cases in Db2 for i where 'NULL' isn't accepted, such as\n    // comparison with a WHERE() statement. In those cases, we have to cast.\n    if (dialectName === 'ibmi' && format) {\n      return 'cast(NULL as int)';\n    }\n\n    return 'NULL';\n  }\n\n  if (Array.isArray(val) && (dialectName !== 'postgres' || format)) {\n    return arrayToList(val, timeZone, dialect, format);\n  }\n\n  const dataType = bestGuessDataTypeOfVal(val, dialect);\n\n  return dataType.escape(val, {\n    dialect,\n    timezone: timeZone,\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAA2B;AAG3B,oBAAuB;AAEvB,SAAS,YAAY,OAAkB,UAA8B,SAA0B,QAAiB;AAG9G,SAAO,MAAM,OAAO,CAAC,KAAa,KAAK,MAAM;AAC3C,QAAI,MAAM,GAAG;AACX,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO,IAAI,YAAY,KAAK,UAAU,SAAS,MAAM;AAAA,IACvD,OAAO;AACL,aAAO,OAAO,KAAK,UAAU,SAAS,MAAM;AAAA,IAC9C;AAEA,WAAO;AAAA,EACT,GAAG,EAAE;AACP;AAEA,MAAM,kBAAkB,oBAAI,IAAmC;AACxD,SAAS,0BAA0B,SAAiD;AACzF,MAAI,OAAO,gBAAgB,IAAI,QAAQ,IAAI;AAC3C,MAAI,QAAQ,MAAM;AAChB,WAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AACvD,oBAAgB,IAAI,QAAQ,MAAM,IAAI;AAAA,EACxC;AAEA,SAAO;AACT;AAEA,SAAS,uBAAuB,KAAc,SAAiD;AAE7F,UAAQ,OAAO,KAAK;AAAA,IAClB,KAAK;AACH,aAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AAAA,IAEzD,KAAK,UAAU;AACb,UAAI,OAAO,cAAc,GAAG,GAAG;AAC7B,eAAO,IAAI,UAAU,QAAQ,EAAE,kBAAkB,OAAO;AAAA,MAC1D;AAEA,aAAO,IAAI,UAAU,KAAK,EAAE,kBAAkB,OAAO;AAAA,IACvD;AAAA,IAEA,KAAK;AACH,aAAO,IAAI,UAAU,QAAQ,EAAE,kBAAkB,OAAO;AAAA,IAE1D,KAAK;AACH,UAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,YAAI,IAAI,WAAW,GAAG;AACpB,gBAAM,IAAI,MAAM,iCAAiC,qBAAO,QAAQ,GAAG,gCAAgC;AAAA,QACrG;AAEA,eAAO,IAAI,UAAU,MAAM,uBAAuB,IAAI,CAAC,GAAG,OAAO,CAAC,EAAE,kBAAkB,OAAO;AAAA,MAC/F;AAEA,UAAI,eAAe,MAAM;AACvB,eAAO,IAAI,UAAU,KAAK,EAAE,kBAAkB,OAAO;AAAA,MACvD;AAEA,UAAI,OAAO,SAAS,GAAG,GAAG;AAExB,YAAI,QAAQ,SAAS,QAAQ;AAC3B,iBAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AAAA,QACzD;AAEA,eAAO,IAAI,UAAU,KAAK,EAAE,kBAAkB,OAAO;AAAA,MACvD;AAEA;AAAA,IAEF,KAAK;AACH,aAAO,0BAA0B,OAAO;AAAA,IAE1C;AAAA,EACF;AAEA,QAAM,IAAI,UAAU,iCAAiC,qBAAO,QAAQ,GAAG,GAAG;AAC5E;AAEO,SAAS,OACd,KACA,UACA,SACA,SAAkB,OACV;AACR,QAAM,cAAc,QAAQ;AAE5B,MAAI,OAAO,MAAM;AAGf,QAAI,gBAAgB,UAAU,QAAQ;AACpC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,GAAG,MAAM,gBAAgB,cAAc,SAAS;AAChE,WAAO,YAAY,KAAK,UAAU,SAAS,MAAM;AAAA,EACnD;AAEA,QAAM,WAAW,uBAAuB,KAAK,OAAO;AAEpD,SAAO,SAAS,OAAO,KAAK;AAAA,IAC1B;AAAA,IACA,UAAU;AAAA,EACZ,CAAC;AACH;",
  "names": []
}
